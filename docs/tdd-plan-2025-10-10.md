# TDD Implementation Blueprint – 2025-10-10

## 1. Context and Scope
Following the 2025-10-10 audit and the subsequent implementation cycle, the baseline ETL pipeline is now in place:

- ✅ Pipeline core (HTML extractor, basic transformer, library loader, CLI entry).

The next priorities focus on rounding out the product experience and operational hardening:

- Streamlit presentation layer (`app/presentation/*`).
- Plugin and prompt infrastructure (`app/plugins/*`, `config/prompts/*`).
- Background workers (`app/workers/*`).
- Knowledge graph execution layer (builder/resolver/repository).
- Operational scripts & configuration artifacts (`scripts/*`, `config/*.yaml`).
- Storage consistency (MinIO bucket naming).
- Cleanup robustness (Qdrant delete error handling).

This blueprint defines a TDD-driven approach to deliver the remaining features while holding our CI coverage bar at **≥90%**.

## 2. TDD Objectives
1. **Guarantee Reproducibility** – codify requirements in executable tests before writing production code.
2. **Maintain the Test Pyramid** – emphasize fast unit tests, complement with pragmatic integration/contract suites, and reserve end-to-end scenarios for critical flows.
3. **Protect Regression Surface** – ensure new modules integrate with existing services without breaking deterministic embeddings, repositories, or service contracts.
4. **Document Behavior via Tests** – use naming conventions and Given/When/Then docstrings to communicate intent to future contributors.

## 3. Global Test Strategy
| Layer | Purpose | Tooling | Notes |
|-------|---------|---------|-------|
| Unit | Validate pure functions, domain rules, small classes | `pytest`, `pytest-asyncio`, `freezegun`, `faker` | Aim for millisecond feedback. Mock external services aggressively. |
| Service / Integration | Exercise inter-module contracts (e.g., pipeline ↔ repositories, plugins ↔ services) | Async fixtures, `pytest` markers, in-memory test doubles (e.g., `aiobotocore.stub` or MinIO docker) | Reuse deterministic embedding helper; prefer real adapters when viable. |
| Contract / Component | Ensure REST/CLI/Streamlit interfaces behave as expected | Snapshot tests for prompts/templates, Streamlit testing via `streamlit.testing` or `playwright` | Capture UI layout, plugin discovery semantics. |
| End-to-End | Validate primary user journeys (ingest → publish → search) | Docker compose test environment, smoke flows | Nightly cadence; keep suite lean to protect CI runtime. |
| Non-functional | Performance budgets, resiliency, lint/type checks | `pytest-benchmark`, `mypy`, `ruff`, `bandit` | Enforce thresholds through CI gates. |

Additional enablers:
- Establish shared factories/fixtures under `tests/factories/` for ProcessedContent, RawContent, Plugin metadata, etc.
- Extend `tests/conftest.py` to provision temporary storage buckets/collections with unique naming per test to avoid clashes.

## 4. Coverage Matrix (What to Build First)
| Workstream | Primary Components | Key Unit Tests | Integration / Contract | Acceptance / E2E |
|------------|-------------------|----------------|------------------------|-------------------|
| Pipeline | `pipeline/etl.py`, `extractors/html.py`, `transformers/basic.py`, `loaders/library.py`, `cli.py` | (Covered) metadata normalization, summary heuristics, tier mapping; (Next) error instrumentation, retry helpers | (Covered) pipeline run writing to local stores; (Next) multi-source expansion (PDF/YouTube) | Extend CLI smoke to cover batch ingestion + failure telemetry |
| Presentation | Streamlit `app.py`, pages, components | Pure layout helpers, state management hooks | Streamlit session flows with fake repositories; accessibility snapshots | Smoke interaction: add content, search, view digest dashboard |
| Plugins & Prompts | Plugin base classes, manager, registry, prompt templates | Plugin discovery, lifecycle hooks, prompt loader validation | Plugin execution with stubbed ContentService, configuration hot-reload | Install sample plugin and run end-to-end ingestion extension |
| Background Workers | Digest, maintenance, ingestion workers | Scheduling logic, exponential backoff, payload serialization | Worker ↔ service integration (e.g., digest worker generates email payload) | Simulated scheduler triggers digest run and observes state transitions |
| Knowledge Graph | Builder, resolver, repository | Node/edge normalization, scoring metrics | Pipeline step adding nodes to graph storage | From ingestion to query UI showing graph visualization |
| Scripts & Config | CLI utilities, YAML loaders | Option parsing, validation, path safety | Script triggers service pipeline with dry-run env | Ops run script in staging; ensures idempotence |
| MinIO Naming Fix | `MinIORepository`, `LibraryService` | Bucket name derivation helper | Migration script verifying existing buckets | Regression scenario: upload + move tiers works across versions |
| Qdrant Cleanup | `QdrantRepository.delete*` | Exception classification helper | Delete path with transient network error stub | Observability pipeline surfaces cleanup failure alerts |

## 5. Detailed Test Case Catalog
The following list anchors RED tests for each feature. `U` = unit, `I` = integration/contract, `E` = end-to-end.

### 5.1 Pipeline
**Existing coverage**
1. **HTML extractor normalizes metadata** (`U`).
2. **Transformer honors summary/key-point limits** (`U`).
3. **Loader routes tiers correctly** (`I`).
4. **CLI run produces JSON/text output** (`I`).

**Next red tests**
1. **Extractor rejects unsupported schemes** (`U`) – tighten error messaging for `ftp://`/`file://`.
2. **Loader logs storage telemetry** (`I`) – structured event emitted when MinIO upload fails.
3. **CLI batch ingest** (`I`) – ensure multiple URLs execute sequentially with partial-failure reporting.
4. **Full ingest smoke** (`E`) – CLI processes fixture feed and asserts tier placement + cached payload.

**Delivered coverage (2025-10-12)**
1. **PDF metadata normalization** (`U`) – `tests/unit/pipeline/test_pdf_extractor.py` covers title fallback, author/subject extraction, and empty-content guard.
2. **Pipeline PDF ingestion** (`I`) – `tests/integration/pipeline/test_pdf_pipeline.py` ensures `ContentPipeline` routes PDF content through transformer and loader stubs.
3. **CLI PDF ingest and failure logging** (`U`/`I`) – `tests/unit/pipeline/test_pipeline_cli.py` and `tests/integration/pipeline/test_pdf_cli.py` exercise PDF-aware routing, JSON output, and URL-scoped error messages.
4. **YouTube transcript extractor** (`U`/`I`/`CLI`) – `tests/unit/pipeline/extractors/test_youtube_extractor.py`, `tests/integration/pipeline/extractors/test_youtube_pipeline.py`, and `tests/integration/pipeline/test_youtube_cli.py` cover transcript extraction, fallback to description, and CLI routing. All tests green at 97.9% coverage.

### 5.2 Presentation (Streamlit)
**Prereqs**
- ✅ Introduced lightweight repository fakes under `tests/factories/streamlit.py` for deterministic UI states (S0-101).
- Capture shared selectors/QA IDs in a constants module so tests resist layout churn.

**Next red tests**
1. **Navigation sidebar lists documented pages** (`U`) – pure function returning nav structure, asserting order and icons.
2. **Library page renders tier filter** (`I`) – Streamlit test ensures dropdown values match config thresholds and pipeline tiers.
3. **Search page caches embeddings** (`I`) – Verify Redis keys set when searching from UI using patched cache repo.
4. **End-user flow** (`E`) – Launch headless Streamlit, add content via UI form, ensure success toast and library count increments.

### 5.3 Plugins & Prompts
**Prereqs**
- ✅ Snapshot fixtures for prompt templates (store under `tests/fixtures/prompts/`).
- ✅ Base plugin scaffold for tests with deterministic hook side effects.

**Next red tests**
1. **Registry rejects duplicate plugin IDs** (`U`) – raises `PluginError` with helpful diagnostics.
2. **Prompt loader fails with missing template** (`U`) – ensures `Path`/`Settings` interplay covered.
3. **Plugin lifecycle** (`I`) – From `on_load` to `before_store` hook using stub plugin and fake pipeline result.
4. **Feature flag gating** (`I`) – Toggle `settings.enable_plugins` to disable registry initialization.
5. **Sample plugin acceptance** (`E`) – Install example plugin, run pipeline, assert hook output recorded and surfaced in CLI telemetry.

### 5.4 Background Workers
**Prereqs**
- ✅ Async clock fixture to fast-forward scheduled jobs (`tests/util/virtual_clock.py`) (S0-102).
- Durable queue abstraction (in-memory) for ingestion worker tests.

**Next red tests**
1. **Job scheduler respects concurrency limit** (`U`) – verifies semaphore usage around job runner.
2. **Digest worker builds email payload** (`I`) – Without SMTP send; uses content factory + snapshot on payload JSON.
3. **Maintenance worker cleans orphaned MinIO files** (`I`) – Works with bucket fix; ensures telemetry event logged.
4. **Cron simulation** (`E`) – Use `apscheduler`/`asyncio` clock to trigger jobs and inspect logs, confirming retries on failure.

### 5.5 Knowledge Graph
**Prereqs**
- Domain factory producing canonical node/edge sets.
- Local `networkx`-backed repository double to avoid heavy DB requirements initially.

**Next red tests**
1. **Builder deduplicates nodes by canonical key** (`U`).
2. **Relationship weight normalization** (`U`).
3. **Repository persists graph snapshot** (`I`) – start with `networkx` + JSON persistence; swap to Postgres later.
4. **Graph query** (`I`) – Service returns top related content for tag.
5. **Dashboard renders graph** (`E`) – Presentation integration showing knowledge graph page using Streamlit testing harness.

### 5.6 Scripts & Config
**Prereqs**
- CLI runner helper to execute scripts within temporary directories.

**Next red tests**
1. **YAML loader validates schema** (`U`).
2. **CLI `--dry-run` leaves no persistent side effects** (`I`).
3. **Bootstrap script** (`E`) – Creates buckets, DB tables, prompts; verify idempotency.

### 5.7 MinIO Naming Fix
**Next red tests**
1. **Bucket suffix helper** (`U`).
2. **Migration script transforms legacy buckets** (`I`).
3. **Tier move regression** (`I`) – move B→A with new helper using fake MinIO client and loader.

### 5.8 Qdrant Cleanup
**Next red tests**
1. **Delete helper ignores NotFound** (`U`).
2. **Delete surfaces other errors with logging** (`I`).
3. **Worker cleans up stale vectors** (`E`) – background job removes entries and emits metrics covering success/failure counts.

### 5.9 CI & Tooling
**Delivered coverage**
1. **Workflow segmentation guard** (`U`) – `tests/unit/ci/test_ci_workflow_configuration.py` ensures the GitHub Actions workflow runs dedicated `unit`, `integration`, and `ui` lanes with marker filters.
2. **Coverage threshold enforcement** (`U`) – the same test suite asserts `--cov-fail-under=90` remains configured in `pyproject.toml`.

## 6. Iterative TDD Workflow
For each workstream, apply the following micro-cycle:

1. **Clarify requirement** – Convert backlog item into Given/When/Then sketch.
2. **Write failing test** – Start with smallest unit; commit message `test: ... fails`.
3. **Implement minimal code** – Fulfil only asserted behavior.
4. **Refactor** – Remove duplication, align naming, push shared helpers to utilities.
5. **Extend tests upward** – After unit green, add necessary integration test before moving on.
6. **Document** – Update README/docs referencing new behavior.

Macro-phases (executed sequentially):

| Phase | Goal | Key Deliverables | Blocking Dependencies |
|-------|------|------------------|-----------------------|
| 0 | Test Infrastructure | Factories, fixture refactors, CI updates, Streamlit testing harness | None |
| 1 | Pipeline Core | ✅ Delivered (HTML extractor, basic transformer, library loader, CLI, unit/integration suite) | Phase 0 |
| 2 | Pipeline Enhancements | Multi-source extractors (PDF/YouTube), telemetry & retries, batch CLI runs | Phase 1 |
| 3 | Plugin + Prompt | Registry, sample plugin, prompt templates with snapshot tests | Phase 0 |
| 4 | Presentation Layer | Streamlit pages/components with UI regression suite | Phases 0–3 (pipeline data + plugin hooks) |
| 5 | Background Workers | Ingestion/digest/maintenance workers with scheduler integration | Phases 1–4 |
| 6 | Knowledge Graph | Builder/resolver + UI integration | Phases 1 & 4 |
| 7 | Ops & Hardening | Scripts, bucket migration, Qdrant cleanup improvements | Prior phases produce functionality to protect |

Each phase should preserve green CI before merging. Feature branches land via pull requests with:
- Test evidence (screenshots/log excerpt) for integration/UI flows.
- Updated documentation for new modules.

## 7. Acceptance Criteria & Definition of Done
- All new code guarded by failing tests written first.
- Test coverage remains ≥ 90% by excluding intentionally unreachable defensive blocks only when justified.
- CI workflow includes new suites (UI/contract) and runs nightly e2e.
- Documentation (`docs/`, README, architecture notes) reflects new capabilities.
- Migration scripts logged and idempotent.

## 8. Reference Backlog (Initial Stories)
1. **Pipeline Batch & Telemetry** – As a maintainer, I can run `poetry run python -m app.pipeline.cli --input sample-feed.json` to ingest multiple URLs and review structured success/error logs.
2. **Plugin Hook Execution** – As a plugin author, my `before_store` hook runs with deterministic input.
3. **Tier Dashboard** – As an analyst, I can open the Streamlit app and view tiered statistics & search.
4. **Digest Worker** – As ops, nightly digest email JSON generated and recorded in Postgres.
5. **Knowledge Graph Visualization** – As a user, I can explore related content graphically.
6. **MinIO Naming Harmonization** – As a maintainer, bucket naming is consistent and migration script verifies success.
7. **Qdrant Cleanup Observability** – As an SRE, failed deletes produce structured logs and metrics.

Each story should have linked RED tests (unit + integration) before implementation begins.

## 9. Tooling & Environment Recommendations
- Extend `docker-compose.yml` with Streamlit, MinIO, Qdrant services for integration testing.
- Use Make/Poetry tasks for running layered test suites (`make test-unit`, `make test-integration`, `make test-ui`).
- Adopt `pytest` markers (`@pytest.mark.pipeline`, `@pytest.mark.ui`) for selective execution.
- Capture Streamlit snapshots using `pytest-playwright` for cross-browser neutral checks.
- Integrate coverage thresholds via `pytest --cov-fail-under=90`.

---
This blueprint should act as a living reference. Update it after each phase to reflect actual test inventory, architectural decisions, and lessons learned from red-green cycles.
